# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

# Load environment variables from .env file
require 'dotenv'
dotenv_path = File.join(__dir__, "..", "..", ".env")
Dotenv.load(dotenv_path) if File.exist?(dotenv_path)

# Check if environment variables are set
required_env_vars = ["APP_STORE_CONNECT_API_KEY_ID", "APP_STORE_CONNECT_ISSUER_ID", "APP_STORE_CONNECT_API_KEY_BASE64", "BUNDLE_ID"]
required_env_vars.each do |var|
  UI.user_error!("Missing required environment variable: #{var}") unless ENV[var]
end

default_platform(:ios)

platform :ios do
  desc "Build and upload a new version to the App Store and TestFlight"
  lane :deploy do
    # Set up App Store Connect API Key globally
    api_key = app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_content: Base64.decode64(ENV["APP_STORE_CONNECT_API_KEY_BASE64"])
    )

    # Inject environment variables into project files
    if ENV["BUNDLE_ID"]
      UI.message("Injecting environment variables...")
      sh "SRCROOT=#{File.expand_path('..')} bash ../scripts/inject_env.sh"
    end

    # Install CocoaPods to ensure dependencies are up to date
    UI.message("Installing CocoaPods dependencies...")
    cocoapods(podfile: "Podfile")

    # Fetch the latest build number from TestFlight and increment it
    begin
      latest_build_number = latest_testflight_build_number(
        app_identifier: ENV["BUNDLE_ID"]
      )
      new_build_number = latest_build_number + 1
    rescue => e
      UI.message("No previous builds found or error fetching build number: #{e.message}")
      UI.message("Starting with build number 1")
      new_build_number = 1
    end

    # Store API key file path for cleanup
    api_key_file_path = nil

    begin
      # Step 1: Clean environment
      UI.message("Step 1: Cleaning build environment...")
      sh "flutter", "clean"
      sh "rm -rf ../../build/ios" rescue UI.message("Build directory already clean")
      
      # Step 2: Prepare dependencies
      UI.message("Step 2: Preparing Flutter dependencies...")
      sh "flutter", "pub", "get"
      
      # Step 3: Handle splash screen (non-blocking)
      UI.message("Step 3: Configuring splash screen...")
      begin
        sh "dart run flutter_native_splash:create"
        UI.success("✅ Splash screen regenerated")
      rescue => e
        UI.important("⚠️ Splash screen generation failed: #{e.message}")
        UI.message("Checking for existing splash files...")
        if Dir.glob("../../ios/Runner/Assets.xcassets/LaunchImage.imageset/*").any?
          UI.success("✅ Found existing splash files, continuing...")
        else
          UI.message("⚠️ No splash files found, but proceeding anyway...")
        end
      end
      
      # Step 4: Set up Xcode environment (only needed for CD)
      if ENV["CD"]
        UI.message("Step 4: Setting up Xcode environment for CI/CD...")
        
        # Ensure Xcode command line tools are configured
        sh "sudo xcode-select -s /Applications/Xcode.app" rescue UI.message("Xcode path already set")
        
        # Create the actual API key file that Xcode/altool needs
        UI.message("Setting up API key file for Xcode...")
        api_key_path = "./private_keys"
        sh "mkdir -p #{api_key_path}"
        api_key_file_path = "#{api_key_path}/AuthKey_#{ENV['APP_STORE_CONNECT_API_KEY_ID']}.p8"
        
        # Write the base64 decoded API key to the .p8 file
        File.write(api_key_file_path, Base64.decode64(ENV['APP_STORE_CONNECT_API_KEY_BASE64']))
        UI.success("✅ API key file created at #{api_key_file_path}")
        
        # Verify the file was created correctly
        if File.exist?(api_key_file_path) && File.size(api_key_file_path) > 0
          UI.success("✅ API key file verified (#{File.size(api_key_file_path)} bytes)")
        else
          UI.error("❌ API key file creation failed")
          raise "API key file was not created properly"
        end
        
        # Verify team access with the API key file
        UI.message("Verifying team access with API key file...")
        begin
          sh "xcrun altool --list-apps --apiKey #{ENV['APP_STORE_CONNECT_API_KEY_ID']} --apiIssuer #{ENV['APP_STORE_CONNECT_ISSUER_ID']} | head -3"
          UI.success("✅ Team access verified with API key file")
        rescue => e
          UI.error("❌ Team access verification failed: #{e.message}")
          UI.message("This means Xcode can't authenticate with Apple")
          raise "Cannot authenticate with Apple - check API key credentials"
        end
        
        # Register app identifier if needed (like local Xcode does automatically)
        UI.message("Ensuring app identifier is registered...")
        begin
          produce(
            app_identifier: ENV["BUNDLE_ID"],
            app_name: "XCeleration",
            team_id: "Y39YWD6Q4X",
            skip_itc: true  # Don't create in App Store Connect, just developer portal
          )
          UI.success("✅ App identifier verified/registered")
        rescue => e
          UI.message("App identifier registration: #{e.message}")
          UI.message("Continuing - app may already be registered")
        end
        
        # Configure automatic code signing with proper team setup
        UI.message("Configuring automatic code signing for CI/CD...")
        update_code_signing_settings(
          path: "Runner.xcodeproj",
          use_automatic_signing: true,  # Keep automatic signing but with proper auth
          team_id: "Y39YWD6Q4X",
          targets: ["Runner", "RunnerTests"]
        )
        
        # Set environment variables that flutter build ipa will use
        ENV["FLUTTER_XCODE_CODE_SIGN_STYLE"] = "Automatic"
        ENV["FLUTTER_XCODE_DEVELOPMENT_TEAM"] = "Y39YWD6Q4X"
        
        UI.success("✅ Xcode environment configured for CI/CD")
      else
        UI.message("Step 4: Skipping Xcode setup (local environment already configured)")
      end
      
      # Step 5: Build IPA (same process for both local and CI/CD)
      build_type = ENV["CD"] ? "CI/CD" : "Local"
      UI.message("Step 5: Building IPA for #{build_type} (using flutter build ipa)...")
      sh "flutter", "build", "ipa", "--release", "--build-number=#{new_build_number}"
      UI.success("✅ #{build_type} build completed successfully!")

      # Upload to TestFlight (same for both local and CI/CD)
      ipa_files = Dir.glob("../../build/ios/ipa/*.ipa")
      bundle_id = ENV["BUNDLE_ID"]
      
      if ipa_files.empty?
        UI.user_error!("No IPA file found for upload")
      end
      
      ipa_path = File.expand_path(ipa_files.first)
      UI.message("Uploading IPA: #{ipa_path}")
      
      upload_to_testflight(
        ipa: ipa_path,
        skip_waiting_for_build_processing: true,
        distribute_external: false,  # Keep this false for internal testing only
        notify_external_testers: false,  # Not needed for internal testing
        groups: ["XCeleration prototype"],  # internal group
        changelog: "Latest updates and bug fixes"  # Optional but recommended
      )
      
    ensure
      # Always revert environment injection to keep git clean
      UI.message("Reverting environment variable injection...")
      sh "SRCROOT=#{File.expand_path('..')} bash ../scripts/revert_env_injection.sh" rescue nil
      
      # Clean up API key file
      if api_key_file_path
        UI.message("Cleaning up API key file...")
        File.delete(api_key_file_path)
        UI.success("✅ API key file cleaned up")
      end
    end
  ensure
    # Fallback cleanup in case of any errors
    UI.message("Final cleanup...")
    sh "SRCROOT=#{File.expand_path('..')} bash ../scripts/revert_env_injection.sh" rescue nil
    
    # Clean up API key file if it exists
    if api_key_file_path && File.exist?(api_key_file_path)
      UI.message("Final API key cleanup...")
      File.delete(api_key_file_path) rescue nil
      UI.success("✅ API key file cleaned up")
    end
  end
end